常用算法

分治算法
基本概念：把一个复杂的问题分成若干个相同或相似的子问题，再把子问题分成更小的子问题… ， 知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。
分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。
分治算法的求解步骤：
1）分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。

2）解决：若子问题规模较小而容易被解决就直接解，否则递归地解各个子问题。

3）合并：将各个子问题的解合并为原问题的解。

分治算法的适用场景：
1）当问题规模缩小到一定的程度就可以很容易解决

2）该问题可以分解为若干个规模较小的相同问题

3）该问题分解出的若干子问题的解可以合并为该问题的解

4）每个子问题都是独立的，相互之间没有交集。
	
使用分治法的经典场景：
1）二分搜索

2）大整数乘法

3）合并排序

4）快速排序

5）汉诺塔

6）循环赛日程表

	归并排序//归并排序是实现分治的一种常用方法

		public static int[] merge(int[] array){
	      if (array.length < 2)
	            return array;
	        int mid = array.length / 2;
	        int[] array1 = Arrays.copyOfRange(array,0,mid);
	        int[] array2 = Arrays.copyOfRange(array,mid,array.length);
			//分治
	        array1 = merge(array1);
	        array2 = merge(array2);
			//合并
	        array = sort(array1,array2);
	        return array;
	    }

		public static int[] sort(int[] array1,int[] array2){
	        int[] array = new int[array1.length + array2.length];
	        int n1 = 0,n2 = 0,n = 0;
	        for (;n1 < array1.length && n2 < array2.length;){
	            if (array1[n1] < array2[n2])
	                array[n++] = array1[n1++];
	            else if (array1[n1] > array2[n2])
	                array[n++] = array2[n2++];
	            else
	                array[n++] = array1[n1++];
	        }
	        for (;n1 < array1.length;)
	            array[n++] = array1[n1++];
	        for (;n2 < array2.length;)
	            array[n++] = array2[n2++];
	        return array;
	    }


-------
	循环赛日程表:
	设有n=2^k个运动员，要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表
	
	    （1）每个选手必须与其他n-1个选手各赛一场
	
	    （2）每个选手一天只能赛一次
	
	    （3）循环赛一共进行n-1天

	将比赛日程表设计成n行n列，表中除了第一列，其他n-1列才是我们要的，
	数组下标行列都从0开始，第i行j列代表第（i+1）位选手在第j天的对手：
分析：按分治策略将所有的选手分成两半，则n个选手的比赛日程表可以通过n/2个选手的比赛日程来决定。递归的用这种一分为二的策略对选手进行划分，知道只剩下两个选手是，只要让这两个选手进行比赛就可以了。
	#include<iostream>
	using namespace std;
	
	#define MAXSIZE 100  //暂时允许的最多的参赛队伍数量 
	int a[MAXSIZE][MAXSIZE]; //将比赛情况放在这个二维表中 
	
	int GameTable(int n,int k){
		if(n == 2){                     //子问题足够小时
			a[k][0] = k+1;
			a[k][1] = k+2;
			a[k+1][0] = k+2;
			a[k+1][1] = k+1;
		} 
		else{
			GameTable(n/2,k);         //划分子问题
			GameTable(n/2,k+n/2);
			for(int i = k; i < k+n/2; i++){    //填充二维表的右上角
				for(int j = n/2; j < n; j++){
					a[i][j] = a[i+n/2][j-n/2];
				}
			}
			for(int i = k+n/2; i < k+n; i++){   //填充二维表的右下角
				for(int j = n/2; j < n; j++){
					a[i][j] = a[i-n/2][j-n/2];
				}
			}
		}
	} 
	
	int main(){
		int n; //队伍数 
		cin>>n;
		
		GameTable(n,0);	 
		for(int i = 0; i < n; i++){
			for(int j = 0; j < n; j++){
				cout<<a[i][j]<<" ";
			}
			cout<<endl;
		}
		return 0;
	} 
